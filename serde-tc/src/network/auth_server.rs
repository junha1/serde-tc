//! This middleware is for the server. It extracts authentication information
//! from the request headers, verifies the signature for the provided payload.
//! Additionally, it injects the public key as the first parameter in the RPC
//! payload for later use.

use std::{
    error::Error,
    task::{Context, Poll},
};

use axum::http::{Request, Response, StatusCode};
use futures::future::BoxFuture;
use hdk_common::{
    crypto::{PublicKey, Signature, TypedSignature},
    serde_hdk,
};
use hyper::Body;
use tower::{Layer, Service};

use super::{utils::get_header, X_HYPERITHM_KEY, X_HYPERITHM_SIGNATURE};
use super::{utils::parse_payload, RpcPayload};

/// Structure to hold authentication information extracted from the request.
struct AuthInfo {
    signature: TypedSignature<RpcPayload>,
    payload: RpcPayload,
}

impl AuthInfo {
    pub fn new(public_key: PublicKey, signature: Signature, payload: RpcPayload) -> Self {
        Self {
            signature: TypedSignature::new(signature, public_key),
            payload,
        }
    }

    pub fn verify(&self) -> Result<(), hdk_common::crypto::CryptoError> {
        self.signature.verify(&self.payload)
    }
}

/// Authentication middleware layer.
///
/// This layer extracts authentication information from the request headers,
/// verifies the signature for the provided payload, and injects the public key
/// as the first parameter in the RPC payload.
#[derive(Debug, Clone)]
pub struct AuthenticationConsumerLayer;

impl<S> Layer<S> for AuthenticationConsumerLayer {
    type Service = AuthenticationConsumer<S>;

    fn layer(&self, inner: S) -> Self::Service {
        AuthenticationConsumer::new(inner)
    }
}

/// Authentication middleware service generated by
/// `AuthenticationConsumerLayer`.
///
/// This middleware performs the authentication and verification process before
/// passing the request to the inner service. If the authentication fails, it
/// responds with an unauthorized error.
#[derive(Debug, Clone)]
pub struct AuthenticationConsumer<S> {
    inner: S,
}

impl<S> AuthenticationConsumer<S> {
    pub(self) fn new(inner: S) -> Self {
        Self { inner }
    }

    async fn authenticate(req: &mut Request<Body>) -> Result<(), eyre::Error>
    where
        S: Service<Request<Body>, Response = axum::response::Response>
            + std::marker::Send
            + Clone
            + 'static,
    {
        let auth_info = Self::extract_auth_info(req).await?;
        auth_info.verify().map_err(|err| err.into())
    }

    async fn extract_auth_info(req: &mut Request<Body>) -> Result<AuthInfo, eyre::Error> {
        let public_key: PublicKey = serde_hdk::from_str(
            &get_header(req, X_HYPERITHM_KEY)
                .ok_or_else(|| eyre::eyre!("falied to get public key"))?,
        )?;
        let signature: Signature = serde_hdk::from_str(
            &get_header(req, X_HYPERITHM_SIGNATURE)
                .ok_or_else(|| eyre::eyre!("falied to get signature"))?,
        )?;

        let mut payload = parse_payload(req).await?;
        let auth_info = AuthInfo::new(public_key.clone(), signature, payload.clone());
        payload.params.insert(
            "caller_key".to_owned(),
            serde_json::to_value(&public_key).expect("failed to serialize public key"),
        );
        let new_body =
            Body::from(serde_json::to_string(&payload).expect("failed to serialize payload"));
        *req.body_mut() = new_body;
        Ok(auth_info)
    }
}

impl<S> Service<Request<Body>> for AuthenticationConsumer<S>
where
    S: Service<Request<Body>, Response = axum::response::Response>
        + std::marker::Send
        + Clone
        + 'static,
    S::Response: 'static,
    S::Error: Into<Box<dyn Error + Send + Sync>> + 'static,
    S::Future: Send + 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = BoxFuture<'static, Result<Self::Response, Self::Error>>;

    #[inline]
    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, mut req: Request<Body>) -> Self::Future {
        let mut inner = self.inner.clone();
        let res_fut = async move {
            match Self::authenticate(&mut req).await {
                Ok(_) => inner.call(req).await,
                Err(err) => Ok(Response::builder()
                    .status(StatusCode::UNAUTHORIZED)
                    .body(axum::body::boxed(Body::from(err.to_string())))
                    .expect("plain response creation")),
            }
        };
        Box::pin(res_fut)
    }
}

#[cfg(never)]
#[cfg(test)]
mod tests {
    use hdk_common::crypto::{generate_keypair, ToHash256};
    use http::HeaderValue;
    use tower::{ServiceBuilder, ServiceExt};

    use super::*;

    async fn call_request(request: Request<Body>) -> Response<Body> {
        let mut svc = ServiceBuilder::new()
            .layer(AuthenticationConsumerLayer)
            .service_fn(|_: Request<Body>| async move {
                Ok::<_, hyper::Error>(Response::new(Body::empty()))
            });
        svc.ready().await.unwrap().call(request).await.unwrap()
    }

    #[tokio::test]
    async fn test_auth() {
        let (public_key, private_key) = generate_keypair("hello world");
        let payload = RpcPayload {
            jsonrpc: serde_json::Value::String("2.0".to_owned()),
            id: serde_json::json!(1),
            method: serde_json::Value::String("foo".to_owned()),
            params: vec![],
        };
        let signature = Signature::sign(payload.to_hash256(), &private_key).unwrap();
        let request = Request::builder()
            .header(
                X_HYPERITHM_KEY,
                HeaderValue::from_str(&serde_hdk::to_string(&public_key).unwrap()).unwrap(),
            )
            .header(
                X_HYPERITHM_SIGNATURE,
                HeaderValue::from_str(&serde_hdk::to_string(&signature).unwrap()).unwrap(),
            )
            .body(Body::from(serde_json::to_string(&payload).unwrap()))
            .unwrap();

        let response = call_request(request).await;
        assert_eq!(response.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_auth_when_no_key() {
        let (_, private_key) = generate_keypair("hello world");
        let payload = RpcPayload {
            jsonrpc: serde_json::Value::String("2.0".to_owned()),
            id: serde_json::json!(1),
            method: serde_json::Value::String("foo".to_owned()),
            params: vec![],
        };
        let signature = Signature::sign(payload.to_hash256(), &private_key).unwrap();
        let request = Request::builder()
            .header(
                X_HYPERITHM_SIGNATURE,
                HeaderValue::from_str(&serde_hdk::to_string(&signature).unwrap()).unwrap(),
            )
            .body(Body::from(serde_json::to_string(&payload).unwrap()))
            .unwrap();

        let response = call_request(request).await;
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
    }

    #[tokio::test]
    async fn test_auth_when_no_signature() {
        let (public_key, _) = generate_keypair("hello world");
        let payload = RpcPayload {
            jsonrpc: serde_json::Value::String("2.0".to_owned()),
            id: serde_json::json!(1),
            method: serde_json::Value::String("foo".to_owned()),
            params: vec![],
        };
        let request = Request::builder()
            .header(
                X_HYPERITHM_KEY,
                HeaderValue::from_str(&serde_hdk::to_string(&public_key).unwrap()).unwrap(),
            )
            .body(Body::from(serde_json::to_string(&payload).unwrap()))
            .unwrap();

        let response = call_request(request).await;
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
    }

    #[tokio::test]
    async fn test_auth_when_wrong_signature() {
        let (public_key, private_key) = generate_keypair("hello world");
        let payload = RpcPayload {
            jsonrpc: serde_json::Value::String("2.0".to_owned()),
            id: serde_json::json!(1),
            method: serde_json::Value::String("foo".to_owned()),
            params: vec![],
        };
        let mut payload2 = payload.clone();
        payload2.method = serde_json::Value::String("bar".to_owned());
        let signature = Signature::sign(payload2.to_hash256(), &private_key).unwrap();
        let request = Request::builder()
            .header(
                X_HYPERITHM_KEY,
                HeaderValue::from_str(&serde_hdk::to_string(&public_key).unwrap()).unwrap(),
            )
            .header(
                X_HYPERITHM_SIGNATURE,
                HeaderValue::from_str(&serde_hdk::to_string(&signature).unwrap()).unwrap(),
            )
            .body(Body::from(serde_json::to_string(&payload).unwrap()))
            .unwrap();

        let response = call_request(request).await;
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
    }
}
